# сервис image-previewer

## Общее описание
Сервис предназначен для изготовления preview (создания изображения
с новыми размерами на основе имеющегося изображения).

## Архитектура
Сервис представляет собой web-сервер (прокси), загружающий изображения,
**масштабирующий/обрезающий** их до нужного формата и возвращающий пользователю.

## Основной обработчик
http://cut-service.com/fill/300/200/raw.githubusercontent.com/OtusGolang/final_project/master/examples/image-previewer/_gopher_original_1024x504.jpg

<---- микросервис ----><- размеры превью -><--------- URL исходного изображения --------------------------------->

В URL выше мы видим:
- http://cut-service.com/fill/300/200/ - endpoint нашего сервиса, в котором 300x200 - это размеры финального изображения.
- https://raw.githubusercontent.com/OtusGolang/final_project/master/examples/image-previewer/_gopher_original_1024x504.jpg - 
адрес исходного изображения; сервис должен скачать его, произвести resize, закэшировать и отдать клиенту.

Сервис должен получить URL исходного изображения, скачать его, изменить до необходимых размеров и вернуть как HTTP-ответ.

- Работаем только с HTTP.
- Ошибки удалённого сервиса или проксируем как есть, или логируем и отвечаем клиенту 502 Bad Gateway.
- Поддержка JPEG является минимальным и достаточным требованием.

**Важно**: необходимо проксировать **все заголовки** исходного HTTP запроса к целевому сервису (raw.githubusercontent.com в примере).

Сервис должен сохранить (кэшировать) полученное preview на локальном диске и при повторном запросе
отдавать изображение с диска, без запроса к удаленному HTTP-серверу.

Поскольку размер места для кэширования ограничен, то для удаления редко используемых изображений необходимо использовать алгоритм **"Least Recent Used"**.

## Конфигурация
Основной параметр конфигурации сервиса - разрешенный размер LRU-кэша.

Он может измеряться как количеством закэшированных изображений, так и суммой их байт (на выбор разработчика).

## Развертывание
Развертывание микросервиса должно осуществляться командой `make run` 
(внутри `docker compose up`) в директории с проектом.

## Тестирование
Реализацию алгоритма LRU нужно покрыть unit-тестами.

Для интеграционного тестирования можно использовать контейнер с Nginx в качестве удаленного HTTP-сервера, раздающего заданный набор изображений.

Необходимо проверить работу сервера в разных сценариях:
* картинка найдена в кэше;
* удаленный сервер не существует;
* удаленный сервер существует, но изображение не найдено (404 Not Found);
* удаленный сервер существует, но изображение не изображение, а скажем, exe-файл;
* удаленный сервер вернул ошибку;
* удаленный сервер вернул изображение;
* изображение меньше, чем нужный размер;
и пр.

## требования для каждого проекта
- Наличие юнит-тестов на ключевые алгоритмы (core-логику) сервиса.
- Наличие валидных Dockerfile и Makefile/Taskfile для сервиса.
- Ветка master успешно проходит пайплайн в CI-CD системе (на ваш вкус, GitHub Actions, Circle CI, Travis CI, Jenkins, GitLab CI и пр.). Пайплайн должен в себе содержать:
    - запуск последней версии golangci-lint на весь проект с конфигом,  представленным в данном репозитории;
    - запуск юнит тестов командой вида go test -race -count 100;
    - сборку бинаря сервиса для версии Go не ниже 1.22.
    
* Реализован HTTP-сервер, проксирующий запросы к удаленному серверу - 2 балла.
* Реализована нарезка изображений - 2 балла.
* Кэширование нарезанных изображений на диске - 1 балл.
* Ограничение кэша одним из способов (LRU кэш) - 1 балл.
* Прокси сервер правильно передает заголовки запроса - 1 балл.
* Написаны интеграционные тесты - 3 балла.
* Тесты адекватны и полностью покрывают функциональность - 1 балл.
* Проект возможно собрать через `make build`, запустить через `make run`
  и протестировать через `make test` - 1 балл.
* Понятность и чистота кода - до 3 баллов.


----------------------------------------------------------------------------------------
## «LRU-кэш»
LRU-кэш реализован на основе двусвязного списка.

### 1) Реализация двусвязного списка
Список имеет структуру вида
```text
nil <- (prev) front <-> ... <-> elem <-> ... <-> back (next) -> nil
```

Реализован следующий интерфейс List:
- Len() int                           // длина списка
- Front() *ListItem                   // первый элемент списка
- Back() *ListItem                    // последний элемент списка
- PushFront(v interface{}) *ListItem  // добавить значение в начало
- PushBack(v interface{}) *ListItem   // добавить значение в конец
- Remove(i *ListItem)                 // удалить элемент
- MoveToFront(i *ListItem)            // переместить элемент в начало

**Считаем, что методы Remove и MoveToFront вызываются только от существующих в списке элементов.**

Элемент списка ListItem:
- Value interface{}  // значение
- Next *ListItem     // следующий элемент
- Prev *ListItem     // предыдущий элемент

Сложность всех операций должна быть O(1),
т.е. нет мест, где осуществляется полный обход списка.

### 2) Реализация кэша на основе ранее написанного списка
Реализован следующий интерфейс Cache:
- Set(key Key, value interface{}) bool  // Добавить значение в кэш по ключу.
- Get(key Key) (interface{}, bool)      // Получить значение из кэша по ключу.
- Clear()                               // Очистить кэш.

Структура кэша:
- ёмкость (количество сохраняемых в кэше элементов)
- очередь \[последних используемых элементов\] на основе двусвязного списка
- словарь, отображающий ключ (строка) на элемент очереди

Элемент кэша хранит в себе ключ, по которому он лежит в словаре, и само значение.

Алгоритм работы кэша:
- при добавлении элемента:
    - если элемент присутствует в словаре, то обновить его значение и переместить элемент в начало очереди;
    - если элемента нет в словаре, то добавить в словарь и в начало очереди
      (при этом, если размер очереди больше ёмкости кэша,
      то необходимо удалить последний элемент из очереди и его значение из словаря);
    - возвращаемое значение - флаг, присутствовал ли элемент в кэше.
- при получении элемента:
    - если элемент присутствует в словаре, то переместить элемент в начало очереди и вернуть его значение и true;
    - если элемента нет в словаре, то вернуть nil и false
    (работа с кешом похожа на работу с `map`)

Имеются следующие тесты:
- на логику выталкивания элементов из-за размера очереди
(например: n = 3, добавили 4 элемента - 1й из кэша вытолкнулся);
- на логику выталкивания давно используемых элементов
(например: n = 3, добавили 3 элемента, обратились несколько раз к разным элементам:
изменили значение, получили значение и пр. - добавили 4й элемент,
из первой тройки вытолкнется тот элемент, что был затронут наиболее давно).

**кэш горутино-безопасный.**
