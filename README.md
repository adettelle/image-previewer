# сервис image-previewer

## Общее описание
Сервис предназначен для изготовления preview (создания изображения
с новыми размерами на основе имеющегося изображения).

## Архитектура
Сервис представляет собой web-сервер (прокси), загружающий изображения,
**масштабирующий/обрезающий** их до нужного формата и возвращающий пользователю.

## Основной обработчик
http://cut-service.com/fill/300/200/raw.githubusercontent.com/OtusGolang/final_project/master/examples/image-previewer/_gopher_original_1024x504.jpg

<---- микросервис ----><- размеры превью -><--------- URL исходного изображения --------------------------------->

В URL выше мы видим:
- http://cut-service.com/fill/300/200/ - endpoint нашего сервиса, в котором 300x200 - это размеры финального изображения.
- https://raw.githubusercontent.com/OtusGolang/final_project/master/examples/image-previewer/_gopher_original_1024x504.jpg - 
адрес исходного изображения; сервис должен скачать его, произвести resize, закэшировать и отдать клиенту.

Сервис должен получить URL исходного изображения, скачать его, изменить до необходимых размеров и вернуть как HTTP-ответ. Поддерживается только JPEG.

Сервис сохраняет (кэширует) полученное preview на локальном диске и при повторном запросе отдаёт изображение с диска, без запроса к удаленному HTTP-серверу.

Поскольку размер места для кэширования ограничен, то для удаления редко используемых изображений используется алгоритм **"Least Recent Used"**.

## Конфигурация
Основной параметр конфигурации сервиса - разрешенный размер LRU-кэша.
Он измеряется количеством закэшированных изображений.
Также можно выбрать, что именно сделать: уменьшить или обрезать изображение.

## Развертывание
Развертывание микросервиса осуществляется командой `make run` 
(внутри `docker compose up`) в директории с проектом.

## Тестирование
Реализацию алгоритма LRU покрыта unit-тестами.

Для интеграционного тестирования используется контейнер с Nginx в качестве удаленного HTTP-сервера, раздающего заданный набор изображений.

Работу сервера  проверена в разных сценариях:
* картинка найдена в кэше;
* удаленный сервер не существует;
* удаленный сервер существует, но изображение не найдено (404 Not Found);
* удаленный сервер существует, но изображение не изображение, а exe-файл;
* удаленный сервер вернул ошибку;
* удаленный сервер вернул изображение;
* изображение меньше, чем нужный размер;

## Реализовано 
* Реализован HTTP-сервер, проксирующий запросы к удаленному серверу.
* Реализована нарезка изображений.
* Кэширование нарезанных изображений на диске (LRU кэш).
* Прокси сервер передает заголовки запроса.
* Написаны интеграционные тесты.
* Написаны юнит-тестов на ключевые алгоритмы (core-логику) сервиса.
* Проект возможно собрать через `make build`, запустить через `make run`
  и протестировать через `make test`.
* Ветка master успешно проходит пайплайн в CI-CD системе (GitHub Actions). Пайплайн содержит в себе:
  - запуск последней версии golangci-lint на весь проект с конфигом,  представленным в данном репозитории;
  - запуск юнит тестов командой вида go test -race -count 100;
  - сборку бинаря сервиса для версии Go не ниже 1.22.


----------------------------------------------------------------------------------------
## «LRU-кэш»
LRU-кэш реализован на основе двусвязного списка.

### 1) Реализация двусвязного списка
Список имеет структуру вида
```text
nil <- (prev) front <-> ... <-> elem <-> ... <-> back (next) -> nil
```

Реализован следующий интерфейс List:
- Len() int                           // длина списка
- Front() *ListItem                   // первый элемент списка
- Back() *ListItem                    // последний элемент списка
- PushFront(v interface{}) *ListItem  // добавить значение в начало
- PushBack(v interface{}) *ListItem   // добавить значение в конец
- Remove(i *ListItem)                 // удалить элемент
- MoveToFront(i *ListItem)            // переместить элемент в начало

**Считаем, что методы Remove и MoveToFront вызываются только от существующих в списке элементов.**

Элемент списка ListItem:
- Value interface{}  // значение
- Next *ListItem     // следующий элемент
- Prev *ListItem     // предыдущий элемент

Сложность всех операций должна быть O(1),
т.е. нет мест, где осуществляется полный обход списка.

### 2) Реализация кэша на основе ранее написанного списка
Реализован следующий интерфейс Cache:
- Set(key Key, value interface{}) bool  // Добавить значение в кэш по ключу.
- Get(key Key) (interface{}, bool)      // Получить значение из кэша по ключу.
- Clear()                               // Очистить кэш.

Структура кэша:
- ёмкость (количество сохраняемых в кэше элементов)
- очередь \[последних используемых элементов\] на основе двусвязного списка
- словарь, отображающий ключ (строка) на элемент очереди

Элемент кэша хранит в себе ключ, по которому он лежит в словаре, и само значение.

Алгоритм работы кэша:
- при добавлении элемента:
    - если элемент присутствует в словаре, то обновить его значение и переместить элемент в начало очереди;
    - если элемента нет в словаре, то добавить в словарь и в начало очереди
      (при этом, если размер очереди больше ёмкости кэша,
      то необходимо удалить последний элемент из очереди и его значение из словаря);
    - возвращаемое значение - флаг, присутствовал ли элемент в кэше.
- при получении элемента:
    - если элемент присутствует в словаре, то переместить элемент в начало очереди и вернуть его значение и true;
    - если элемента нет в словаре, то вернуть nil и false
    (работа с кешом похожа на работу с `map`)

Имеются следующие тесты:
- на логику выталкивания элементов из-за размера очереди
(например: n = 3, добавили 4 элемента - 1й из кэша вытолкнулся);
- на логику выталкивания давно используемых элементов
(например: n = 3, добавили 3 элемента, обратились несколько раз к разным элементам:
изменили значение, получили значение и пр. - добавили 4й элемент,
из первой тройки вытолкнется тот элемент, что был затронут наиболее давно).

**кэш горутино-безопасный.**
